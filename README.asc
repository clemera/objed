:experimental:

++++
<a href="https://elpa.gnu.org/packages/objed.html"><img alt="ELPA" src="https://elpa.gnu.org/favicon.png"/></a>
<a href="https://stable.melpa.org/#/objed"><img alt="MELPA Stable" src="https://stable.melpa.org/packages/objed-badge.svg"/></a>
<a href="https://melpa.org/#/objed"><img alt="MELPA" src="https://melpa.org/packages/objed-badge.svg"/></a>
++++

= Objed - The text object editor

A global minor-mode to navigate and edit text objects. Objed also enables
modal editing and composition of commands. It combines ideas of
http://emacs-versor.sourceforge.net/[versor-mode] and other Editors like Vim
or Kakoune and tries to align them with regular Emacs conventions.

For more information you can read my
https://www.with-emacs.com/categories/objed/[posts] about `objed` and for
changes check the https://github.com/clemera/objed/blob/master/News.asc[News]
file.

== Introduction

Text objects are textual patterns like a line, a top level definition, a word,
a sentence or any other unit of text. When `objed-mode` is enabled, certain
editing commands (configurable) will activate `objed` and enable its modal
editing features. When active, keys which would usually insert a character are
mapped to objed commands. Other keys and commands will continue to work as
they normally would and exit this editing state again.

By default important editing keys like kbd:[Space], kbd:[DEL] or kbd:[Return]
are not bound to modal commands and will execute the regular command and exit
`objed`. Character movement exits `objed`, as well. This makes it convenient
to move around and continue by adding/deleting text.

With activation `objed` shows the current object type in the `mode-line`. The
textual content of the object is highlighted visually in the buffer and the
cursor color is changed, too. The user can now navigate by units of this
object, change the object state or switch to other object types.

The object state is either `inner` or `whole` and is indicated in the modeline
by `(i)` or `(w)` after the object type. With inner state, anything that would
be considered delimiters or padding around an object is excluded.

The user can apply operations to objects. By marking objects before applying
an operation, s?he can even operate on multiple objects at once. This works
similar to the way you interact with files in `dired`. When marking an object
the point moves on to the next object of this type.

The object type used for initialization is determined by the mapping of the
entry command (see `objed-cmd-alist`). For example using `beginning-of-defun`
will activate `objed` using the `defun` object as initial object type. With
command `next-line`, `objed` would initialize with the `line` object. To
activate `objed` without movement you can use `objed-activate`, bound to
kbd:[M-SPC] by default. It uses the last command and its mapping in
`objed-command-alist` to choose the initial object.

Objeds modal state provides basic movement commands which move by line, sexp
or word. Those switch automatically to the corresponding object type. Other
commands only activate the part between the initial position and the new
position moved to. By repeating commands you can often expand/proceed to other
objects. This way you can compose movement and editing operations very
efficiently.

The expansion commands distinguish between block objects (objects built out of
lines of text) and context objects (programming constructs like strings,
brackets or textual components like sentences). This way you can quickly
expand to the desired objects.

For example to move to the end of the paragraph, the user would first move to
the end of the line with kbd:[Ctrl - e]. This would activate `objed` using the
line object with the text moved over. The user can now continue to the end of
the paragraph by pressing kbd:[e] again. Now s?he is able to proceed even
further by pressing kbd:[e] again OR to continue by adding new text to the end
of the paragraph OR to continue by acting on the text moved over, for example
killing it by pressing kbd:[k].

As often with text editing, the explanation sounds more complicated than using
it. To get a better impression of the editing workflow with `objed` I have
added some animated demos below.

To learn more about available features and commands have a look at the
descriptions below, the commentary section or the docstrings and bindings
defined in `objed-map`. To define your own operations and text objects see
`objed-define-op` and `objed-define-object`.

Note that `objed` is *still evolving*, some *bindings might change* in this
process. Because of that the following screencasts might not always show up to
date key bindings.


## Examples of usage

.Object navigation
image::./images/object_nav.gif[Object navigation]

++++
<br>
++++

.Object expansion
image::./images/expand_context.gif[Object expansion]

++++
<br>
++++

.End of block expansion
image::./images/end_of_block.gif[End of block expansion]

++++
<br>
++++

.Upto context
image::./images/upto.gif[Upto context]

++++
<br>
++++

.Marking objects and act on them
image::./images/reorder_lines_by_marking.gif[Marking objects and act on them]

++++
<br>
++++

.Mark objects inside another one
image::./images/remove_comments_in_defun.gif[Mark objects inside another one]

++++
<br>
++++

.Select current object type with avy
image::./images/senteces_avy.gif[Select current object type with avy]

++++
<br>
++++

.Navigate and search output object
image::./images/output_occur.gif[Navigate and search output object]

++++
<br>
++++

## Keys

Although some features are still experimental the basic user interface will
stay the same. The following gives an overview of available keys and commands.
If commands allow for numeric arguments you can input them without the use of
kbd:[Ctrl] or kbd:[Meta]. kbd:[0] can be used as an alternative for the
universal argument (kbd:[C-u]).

In addition to the commands configured in `objed-cmd-alist` you can use the
following commands to enter objed (those bindings are only active if you are
using `objed-mode`, if you choose to activate objed always manually you have
to bind those commands in you `global-map`):

[`objed-mode-map`]
|===
|Shortcut |Purpose
|kbd:[C-,/C-.]
|Move to previous/next identifier and activate `identifier` object.

|kbd:[M-[]
|Activate object at point (determined from context) and move to its start.

|kbd:[M-\]]
|Activate object at point (determined from context) and move to its end.

|kbd:[M-SPC]
|Activate objed, choosing initial object based on `last-command` and `objed-cmd-alist`.
|===

Basic movement commands (switch the object type on movement):

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[f/b]
|Move forward/backward one sexp and activate the sexp object

|kbd:[s/r]
|Move forward/backward one word and activate the word object.

|kbd:[n/p]
|Move to the next/previous line and activate the line object.
|===

Commands for block objects (objects built out of lines of text):

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[h]
|Activate (line based) object at point and move to its start. On repeat proceed to beginning of the indentation block, comment block, paragraph or other block objects.

|kbd:[a]
|Move to beginning of line and activate the text moved over. On repeat proceed to beginning of blocks like explained above.

|kbd:[e]
|Move to end of line and activate the text moved over. On repeat proceed to end of blocks like explained above.
|===

Commands for context objects. Those objects are common programming constructs
like defuns, strings, parentheses but also sentences inside comments for
example. Any whitespace after point is skipped before determining the context:

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[o]
|Activate the inner part of the object at point and move to the start. This is useful to act on the content of the string, brackets and so on. On repeat expand to other objects around current position.

|kbd:[j]
|Move point to the other side of the current object.

|kbd:[t]
|Toggle the state of the current object (inner/whole).

|kbd:[[/\]]
|If coming from basic movement the object at point is guessed based on context. Point is moved  to the beginning/end of object at point. This is useful to "jump out" of the current context. On repeat move to the previous/next instance of current object type

|kbd:[(/)]
|Move to inner beginning/end of the object at point and activate the text moved over.

|kbd:[{/}]
|Move forward/backward paragraph and switch to paragraph object

|kbd:[</>]
|Goto first/last instance of current object type (https://with-emacs.com/posts/objed/spotlight-objed-move-to-first-or-last-instance/[blog]).
|===

Commands to switch objects (and move point to its start, repeating an object
command mark all instances in current defun/buffer):

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[.]
|Switch to identifier object.

|kbd:[_]
|Switch to symbol object.

|kbd:[l]
|Switch to line object.

|kbd:[c]
|Prefix to switch to other objects, see `objed-object-map` for available objects and `objed-define-object` to add your own (https://with-emacs.com/posts/objed/writing-your-own-text-objects-for-objed/[blog]).
|===


Indent/Move objects around:

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[C-left/C-right]
|Move/indent all lines in object right/leftward.

|kbd:[M-left/M-right]
|Move/indent all lines in object to right/leftward to tab stop.

|kbd:[S-left/S-right/S-up/S-down/F/B]
|Move current object type forward/backward (https://with-emacs.com/posts/i-like-to-move-it-emacs-version/[blog]).

|kbd:[S/R]
|Switch to word object and move it forward/backward.

|kbd:[N/P]
|Switch to line object and move it forward/backward.
|===


Commands to edit objects (applying operations to them). When the region is
active the operation acts on the current region. To act on multiple objects at
once you can mark them first (see the "Misc commands" below):

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[i]
|Delete current object(s) and switch to insert.

|kbd:[k]
|Kill current object(s).

|kbd:[d]
|Delete current object(s).

|kbd:[w]
|Copy current object(s). On repeat move to next and append it to `kill-ring`

|kbd:[y]
|Yank last killed text at point. On repeat, cycle through `kill-ring`

|kbd:[\ ]
|Indent object(s).

|kbd:[;]
|Un/comment object(s).

|kbd:[%]
|Query replace narrowed to current object.

|kbd:[!]
|Replace object(s) with minibuffer input.

|kbd:[&]
|Pipe object region through shell command.

|kbd:[\|]
|Incrementally construct command chain to replace text (https://with-emacs.com/posts/objed/incremental-construction-of-command-chains-to-replace-text/[blog]).

|kbd:[Ctrl - RET]
|Evaluate current object in REPL (need `eval-in-repl` to be installed).

|kbd:[M - RET]
|Insert new (empty) instance of current object type. This inserts the current object without the inner content.

|kbd:[S - RET]
|Comment and duplicate object.

|kbd:[$]
|Spell check textual content of object using `flyspell`.

|kbd:[~]
|Undo in current object region.

|kbd:[']
|Add surroundings to object(s) with any pair using `electric` (built-in).

|kbd:[x]
|Prefix to access other operations, see `objed-op-map` for available operations and `objed-define-op` to add your own.

|===

Misc commands:

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[q]
|Quit window if not the only one.

|kbd:[,]
|Pop to last state, which restores the last position and any object data.

|kbd:[M-o]
|Choose an instance of current object type with completion, using the contents of the first line for completion.

|kbd:[`]
|Choose an instance of current object type on the screen with `avy` (https://with-emacs.com/posts/objed/jump-around-emacs-version/[blog]).

|kbd:[m]
|Add/Remove current object to marked objects and move to next.

|kbd:[M]
|Add/Remove current object to marked objects and move to previous.

|kbd:[v]
|Activate region with current object (extend current object).

|kbd:[Ctrl - Space]
|Set mark.

|kbd:[/]
|Undo last edit command.

|kbd:[?]
|Get key binding help (uses `which-key` if available).

|kbd:[g/Ctrl - g]
|Exit and deactivate `objed`.
|===


Dispatch keys (dispatch to any object defined in `objed-object-map`).
You can add your own prefix bindings using `objed-define-dispatch`.

[`objed-map`]
|===
|Shortcut |Purpose

|kbd:[*]
|Mark all instances of current object inside another object type.

|kbd:[#]
|Switch to another object using `avy`.

|kbd:[u]
|Activate part from point forward until boundary of some object.

|kbd:[z]
|Activate part from point backward until boundary of some object.

|kbd:[-/+]
|Extend current object forward/backward by including leading/trailing whitespace.
|===


== Installation


`Objed` is on MELPA and GNU ELPA, for installation use:

```emacs
M-x package-refresh-contents RET
M-x package-install RET objed RET
;; activate objed-mode in you init
(objed-mode)
```
For manual installation:

```sh
git clone http://github.com/clemera/objed.git
```
Add this to your init file:

```elisp
(add-to-list 'load-path "/<path-to>/objed")
(require 'objed)
(objed-mode)
;; activating the mode is optional, you can activate objed
;; always manually using `objed-activate' the other
;; commands bound in `objed-mode-map`, for example:
;; (global-set-key (kbd "M-SPC") 'objed-activate)
```

== Contribute

I'm happy to receive pull requests or ideas to improve this package. Some
parts suffer from the bottom up approach of developing it, but this also
allowed me to experiment a lot and try ideas while working on them, something
that Emacs is especially good at. Most of the features are tested using
`emacs-lisp-mode` but hopefully there aren't to many problems using modes for
other languages. Before submitting a PR please check your code compiles
cleanly and all tests are passing:

```sh
make test
```

=== Copyright Assignment


This package is subject to the same
https://www.gnu.org/prep/maintain/html_node/Copyright-Papers.html[Copyright Assignment]
policy as Emacs itself, org-mode, CEDET and other packages in https://elpa.gnu.org/packages/[GNU ELPA].

Any
https://www.gnu.org/prep/maintain/html_node/Legally-Significant.html#Legally-Significant[legally significant]
contributions can only be accepted after the author has completed
their paperwork. Please see
https://git.savannah.gnu.org/cgit/gnulib.git/tree/doc/Copyright/request-assign.future[the request form]
if you want to proceed with the assignment.

